reg型和wire型。always块中的输出信号必须被描述成reg型，而不是默认的wire型。
在verilog中，各语句是并发执行的，不分先后，除了if是顺序。顺序执行的语句必需包含在always或initial块中
串行接口是指信息是在单根信号线上按序一位一位发送的
**异步复位**指复位信号的生效与**时钟信号无关**，只要复位信号满足有效条件，电路会**立即**进入复位状态（如输出清零、寄存器置初始值），无需等待时钟边沿触发。
**低电平**有效指**复位信号**为**低电平**（0）时**生效**，高电平时无效。这类信号通常会在命名中加后缀_n表示负逻辑
在PS/2协议中，数据在时钟**下降沿**时稳定，

regerror用法
regcomp
strtol用法
regexec
strncpy
strtok
panic

以下是`regcomp`、`regexec`、`regerror`、`strtol`、`strncpy`、`strtok`、`panic`的详细用法说明，包括函数原型、参数含义、返回值及使用示例：


### 一、`regcomp`——编译正则表达式
**功能**：将字符串形式的正则表达式编译为可执行的内部格式（提升匹配效率），用于后续`regexec`匹配。

#### 函数原型
```c
#include <regex.h>
int regcomp(regex_t *preg, const char *regex, int cflags);
```

#### 参数说明
- `preg`：输出参数，指向`regex_t`结构体，用于存储编译后的正则表达式。
- `regex`：输入参数，待编译的正则表达式字符串（如`"[0-9]+"`）。
- `cflags`：编译选项（可组合使用，用`|`连接）：
  - `REG_EXTENDED`：使用扩展正则表达式（支持`|`、`()`等），不使用则为基本正则表达式。
  - `REG_ICASE`：忽略大小写匹配。
  - `REG_NOSUB`：不需要捕获子串（仅判断是否匹配，不保存分组结果）。
  - `REG_NEWLINE`：处理换行符（默认`.`不匹配`\n`，此选项下`^`匹配行首、`$`匹配行尾）。

#### 返回值
- 成功：`0`；失败：非0（错误码，可通过`regerror`转换为错误信息）。

#### 使用示例
```c
#include <stdio.h>
#include <regex.h>

int main() {
    regex_t reg;
    // 编译正则表达式：匹配至少1个数字（扩展模式）
    int ret = regcomp(&reg, "[0-9]+", REG_EXTENDED);
    if (ret != 0) {
        printf("正则编译失败\n");
        return 1;
    }
    // 使用后需释放
    regfree(&reg);
    return 0;
}
```


### 二、`regexec`——执行正则表达式匹配
**功能**：使用`regcomp`编译后的正则表达式，匹配目标字符串。

#### 函数原型
```c
#include <regex.h>
int regexec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
```

#### 参数说明
- `preg`：`regcomp`编译后的正则表达式（`regex_t`结构体）。
- `string`：待匹配的目标字符串。
- `nmatch`：`pmatch`数组的长度（指定最多捕获多少个子串）。
- `pmatch`：输出参数，`regmatch_t`数组，存储匹配到的子串位置（仅当`regcomp`未指定`REG_NOSUB`时有效）：
  - `pmatch[0]`：整个匹配串的起始和结束位置（`rm_so`：起始索引，`rm_eo`：结束索引+1）。
  - `pmatch[1...]`：捕获的子串（分组）位置。
- `eflags`：匹配选项（通常为`0`）：
  - `REG_NOTBOL`：`^`不匹配字符串开头；`REG_NOTEOL`：`$`不匹配字符串结尾。

#### 返回值
- 成功匹配：`0`；失败：`REG_NOMATCH`（无匹配）或其他错误码。

#### 使用示例
```c
// 接上面regcomp的示例，匹配字符串"abc123def"中的数字
char *str = "abc123def";
regmatch_t pmatch[1]; // 存储整个匹配结果
int ret = regexec(&reg, str, 1, pmatch, 0);
if (ret == 0) {
    // 提取匹配的子串（从rm_so到rm_eo）
    printf("匹配到: %.*s\n", pmatch[0].rm_eo - pmatch[0].rm_so, str + pmatch[0].rm_so);
    // 输出：匹配到: 123
} else if (ret == REG_NOMATCH) {
    printf("无匹配\n");
}
```


### 三、`regerror`——获取正则表达式错误信息
**功能**：将`regcomp`或`regexec`返回的错误码转换为人类可读的错误信息。

#### 函数原型
```c
#include <regex.h>
size_t regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size);
```

#### 参数说明
- `errcode`：`regcomp`或`regexec`返回的错误码。
- `preg`：`regcomp`编译后的正则表达式（若错误来自`regcomp`，需传入；否则可为`NULL`）。
- `errbuf`：输出参数，存储错误信息的缓冲区（若为`NULL`，仅返回所需缓冲区大小）。
- `errbuf_size`：`errbuf`的大小（字节）。

#### 返回值
- 成功：错误信息的总长度（包括`\0`）；若`errbuf_size`不足，返回所需最小长度。

#### 使用示例
```c
// 编译失败时获取错误信息
int ret = regcomp(&reg, "[0-9", REG_EXTENDED); // 错误的正则（缺少右括号）
if (ret != 0) {
    char errbuf[128];
    regerror(ret, &reg, errbuf, sizeof(errbuf));
    printf("编译错误: %s\n", errbuf); // 输出：未结束的括号
}
```


### 四、`strtol`——字符串转换为长整数（支持进制）
**功能**：将字符串按指定进制转换为`long`类型整数，支持跳过前缀空格、检测无效字符。

#### 函数原型
```c
#include <stdlib.h>
long int strtol(const char *nptr, char **endptr, int base);
```

#### 参数说明
- `nptr`：输入参数，待转换的字符串（如`"123"`、`"0x1a"`）。
- `endptr`：输出参数（可选），指向转换终止的位置（未转换的第一个字符）；若为`NULL`，则忽略。
- `base`：转换进制（`2~36`，或`0`自动识别：`0x`开头→16进制，`0`开头→8进制，否则10进制）。

#### 返回值
- 成功：转换后的`long`整数；
- 失败：若超出范围，返回`LONG_MAX`或`LONG_MIN`，并设置`errno = ERANGE`；若无法转换（无有效数字），返回`0`。

#### 使用示例
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    char *str = "  0x1aabc"; // 带前缀空格和16进制数
    char *end;
    long num = strtol(str, &end, 0); // base=0自动识别（0x开头→16进制）
    printf("转换结果: %ld\n", num); // 0x1a=26 → 输出：26
    printf("未转换的部分: %s\n", end); // 输出：abc（转换到'abc'停止）
    return 0;
}
```


### 五、`strncpy`——有限长度字符串复制
**功能**：将源字符串的前`n`个字符复制到目标缓冲区（相比`strcpy`，可避免缓冲区溢出）。

#### 函数原型
```c
#include <string.h>
char *strncpy(char *dest, const char *src, size_t n);
```

#### 参数说明
- `dest`：目标缓冲区（需预先分配空间）。
- `src`：源字符串（以`\0`结尾）。
- `n`：最大复制字符数（包括`\0`）。

#### 行为说明
- 若`src`长度≤`n`：复制整个`src`（包括`\0`），剩余位置不填充（可能不含`\0`）。
- 若`src`长度> `n`：复制前`n`个字符，**不自动添加`\0`**（需手动补`\0`）。

#### 使用示例
```c
char dest[10];
char *src = "hello";
strncpy(dest, src, sizeof(dest)); // 复制"hello\0"到dest（长度5+1=6 ≤10）
// 若src过长（如"helloworld123"），需手动补\0：
strncpy(dest, src, sizeof(dest)-1); // 复制前9个字符
dest[sizeof(dest)-1] = '\0'; // 确保结尾有\0
```


### 六、`strncpy`注意事项
- 不会自动在`dest`末尾添加`\0`（除非`src`长度≤`n`），需手动处理，否则可能导致字符串未终止。
- 适合精确控制复制长度的场景（如固定长度字段），普通字符串复制建议用`strlcpy`（非标准但更安全）。


### 七、`strtok`——字符串分割（按分隔符拆分）
**功能**：将字符串按指定分隔符拆分（如用空格拆分命令行参数），需多次调用。

#### 函数原型
```c
#include <string.h>
char *strtok(char *str, const char *delim);
```

#### 参数说明
- `str`：第一次调用时传入待拆分的字符串；后续调用传入`NULL`（表示继续处理上一次的字符串）。
- `delim`：分隔符集合（如`" ,\t"`表示空格、逗号、制表符均为分隔符）。

#### 行为说明
- 第一次调用：跳过`str`开头的分隔符，返回第一个非分隔符开始的子串（结尾替换为`\0`）。
- 后续调用（`str=NULL`）：从上次结束位置继续，返回下一个子串；若已无更多子串，返回`NULL`。
- **会修改原字符串**（用`\0`替换分隔符），若需保留原字符串，需先复制。

#### 使用示例
```c
char str[] = "a,b,c,d"; // 必须是可修改的数组（不能是常量字符串）
char *delim = ",";

// 第一次调用：拆分第一个子串
char *token = strtok(str, delim);
while (token != NULL) {
    printf("子串: %s\n", token); // 依次输出a、b、c、d
    token = strtok(NULL, delim); // 后续调用传入NULL
}
```


### 八、`panic`——进程异常终止（打印错误并退出）
**功能**：用于处理致命错误（如内存分配失败），打印错误信息并终止进程（类似`exit`但更简洁）。

#### 说明
- **非标准函数**：C标准库中无`panic`，通常是系统或应用自定义的函数（如Linux内核、BSD系统）。
- 常见实现：打印错误信息（如`"panic: out of memory"`），然后调用`abort()`终止进程（产生核心转储）。

#### 典型实现（示例）
```c
#include <stdio.h>
#include <stdlib.h>
void panic(const char *msg) {
    fprintf(stderr, "panic: %s\n", msg);
    abort(); // 终止进程，生成core dump
}
```

#### 使用场景
- 用于不可恢复的错误（如初始化失败、内存分配失败），示例：
```c
int *ptr = malloc(1024);
if (ptr == NULL) {
    panic("malloc failed"); // 打印错误并退出
}
```


### 总结
| 函数       | 核心用途                          | 关键注意点                                  |
|------------|-----------------------------------|---------------------------------------------|
| `regcomp`  | 编译正则表达式                    | 需配合`regfree`释放资源                      |
| `regexec`  | 执行正则匹配                      | 通过`pmatch`获取匹配位置                    |
| `regerror` | 正则错误信息转换                  | 需传入错误码和编译后的正则                   |
| `strtol`   | 字符串转长整数（支持进制）        | 检查`endptr`判断是否完全转换，处理`ERANGE`   |
| `strncpy`  | 有限长度字符串复制                | 需手动添加`\0`，避免未终止字符串             |
| `strtok`   | 字符串分割                        | 会修改原字符串，多次调用需传入`NULL`         |
| `panic`    | 致命错误处理                      | 非标准，需自定义，用于不可恢复错误           |

这些函数在系统编程、文本处理中非常常用，需注意参数合法性和返回值处理（尤其是错误场景）。

atoi从字符串中提取十进制数

递归：
int f(int n){
  if(n==0){
    return 1;}
    else{
      return n*f(n-1);
    }
  }
 数列：
 int f(int n){
 if(n==0) return 0;
 else if(n==1) return 1;
 else return f(n-1)+f(n-2);}

锁存器：是数字电路中异步时序逻辑电路系统中用来存储信息的一种电子电路。
RS锁存器。S为0时保持，S,R相反时随S，S为1时不允许。
D锁存器：G为0时保持，G为1时随D。


 
