指令周期:取指-译码-执行
取指将PC指向的指令从内存读入到CPU中
CPU在拿到一条指令之后，可以通过查表的方式得知这条指令的操作数和操作码，这个过程叫做译码
经过译码之后，CPU就知道当前指令具体要做什么了
更新PC，


1.操作系统概述：
程序合成
why，what，how
为什么要学操作系统
先讲具体的再讲抽象的
为了最大化分数而失去了integrate
什么是操作系统
a body of software,making it easy to run programs
管理软硬件资源，微程序提供服务




2.
                                                            **状态机**
                                                          **C程序的语义**
gcc -E a.c 展开宏
栈帧
C语言程序由很多栈帧组成
                                                          **机器代码语义**

总结
程序=状态机
  源代码S：状态迁移=执行语句
  二进制代码C:状态转移=执行指令
  编译器C=compile（S）

应用视角的操作系统

  就是一条syscall指令
计算机系统不存在玄学：一切都建立在确定的机制上
  理解操作系统的重要工具：gcc,binutils,gdb,strace

                                                    **3.多处理器编程**
操作系统是最早的并发程序之一
多处理器系统
**并发**快速轮流
和**并行**：真正物理上同时进行

**线程API**                
create（fn）  
创建一个入口函数是fn的线程，并立即开始执行
语义：在状态中新增stack frame列表并初始化为fn(tid)
join()
等待所有运行的线程的fn返回
在main返回时会自动等待所有线程结束
语义：在有其他线程未执行完时死循环，否则返回
**编译时要增加 -lpthread**

证明线程确实共享内存
证明线程具有独立堆栈（以及确定它们的范围）
私房菜学Linux
man 7 pthreads
POSIX为我们提供了线程库
改写thread.h，使得线程拥有更大的栈
多处理器系统中的线程的代码可能**同时**执行
  两个线程同时执行x++

  
**lock**
**unlock**
  实现临界区之间的绝对串行化
  程序的其他部分依然可以并行执行
  99%的并发问题都可以用一个队列解决
    把大任务切分为可并行的小任务
    worker thread去锁保护的队列里取任务
    除去不可并行的部分，剩下的部分可以获得线性的加速

    
系统调用不可优化的石头
内存可优化
1.atomic关键字可以帮我们生成原子化的读-改-写操作，从而避免多线程竞争问题
2.atomic有着极高的运行效率
3.atomic的特性是不稳定的
4.不是所有的编译器都支持Atomic


1.系统调用和函数调用一样，都可以通过寄存器传递参数，但会用syscall指令触发CPU异常，从而让操作系统接管后面的功能实现
2.操作系统调用会引发：CPU状态转换，CPU在用户态准备参数，然后切换到内核态完成功能
3.系统调用能够有效的隔离：应用程序和操作系统核心，提高整个系统的安全性
4.系统调用的实现，会因为CPU指令集的不同而不同，几乎所有重要的库函数都需要通过：系统调用来实现
过程：1.执行系统调用参数（用户态）2.执行陷入指令（用户态）3.执行相应的服务程序（内核态）4.返回用户态

            {用户态                   {特权指令                            {命令接口
CPU运行模式                   指令                        操作系统接口      {程序接口    命令接口和图形接口都需要用到系统调用
            {核心态                   {非特权指令                          {图形接口
自陷指令运行于用户态，是非特权指令
syscall是自陷指令

解决CPU大小端问题：用字符串的形式传递数值

**函数括号，堆栈，栈帧**
1.操作系统会为每个任务分配一段内存，当做任务堆栈，CPU则提供2个寄存器esp和ebp,用来标识：当前函数对堆栈的使用情况，随着函数的逐层调用，函数的栈帧会逐次堆叠，互不重合，随着函数的逐层返回，函数的栈帧会被就地放弃，但不会清理内存
2.正括号{用来保护上层主调函数（main）的栈帧，并设置被调函数（func）的栈帧，反括号}用来放弃被调函数的栈帧，同时，恢复主调函数（main）的栈帧。这样，被调函数执行完后，主调函数就能继续执行
3.ebp寄存器作为当前函数的栈帧基地址，配合一定的偏移，就可以读写函数体里的临时变量，如果一个变量是通过ebp寄存器间接访问的，那么它往往是临时变量，也叫栈变量
4.不同编译器对栈帧的实现方法略有不同，但思路相同

**堆栈隐患**
1.主调函数在调用函数时会把返回地址偷偷存放在堆栈中
2.被调函数返回时，会从堆栈中取出返回地址，引导CPU跳回到主调函数
3.不同编译器，在实现函数的返回上，会略有不同
缺点：返回地址这种关键数据离临时变量太近，容易被越界访问，导致程序意外崩溃
