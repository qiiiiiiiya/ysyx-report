指令周期:取指-译码-执行
取指将PC指向的指令从内存读入到CPU中
CPU在拿到一条指令之后，可以通过查表的方式得知这条指令的操作数和操作码，这个过程叫做译码
经过译码之后，CPU就知道当前指令具体要做什么了
更新PC，

**make** 提供的两个有用的选项
**-n** 只打印命令不运行
**-B** 强制 make 所有目标

**Ctrl+Z** 是 “临时暂停并后台存放” 进程的快捷键，给用户提供了 “先处理其他任务，之后再恢复原进程” 的灵活性，这也是它和 “直接杀死进程” 的 **Ctrl+C** 最核心的区别。
恢复到前台运行：使用jobs命令查看当前会话中的所有后台任务及其编号，然后使用fg %任务编号将特定任务恢复到前台运行。例如，jobs命令显示暂停的任务编号为 1，则执行fg %1可将其恢复到前台。如果不指定任务编号，fg命令会恢复带有 “+” 标志的任务，该标志代表最近一个放入后台的工作。
恢复到后台运行：同样先使用jobs命令查看任务编号，然后使用bg %任务编号将选中的任务在后台继续运行。例如，对于编号为 1 的任务，执行bg %1可使其在后台恢复运行。若不指定任务编号，bg命令默认恢复带有 “+” 标志的任务。

1.操作系统概述：
程序合成
why，what，how
为什么要学操作系统
先讲具体的再讲抽象的
为了最大化分数而失去了integrate
什么是操作系统
a body of software,making it easy to run programs
管理软硬件资源，微程序提供服务




2.
                                                            **状态机**
                                                          **C程序的语义**
gcc -E a.c 展开宏
栈帧
C语言程序由很多栈帧组成
                                                          **机器代码语义**

总结
程序=状态机
  源代码S：状态迁移=执行语句
  二进制代码C:状态转移=执行指令
  编译器C=compile（S）

                                                                             **2.应用视角的操作系统**
给C语言写一个解释器
  file a.out
  nm a.out
  objdump -d a.out
  objdump -h a.out
  
  就是一条syscall指令
计算机系统不存在玄学：一切都建立在确定的机制上
  理解操作系统的重要工具：gcc,binutils,gdb,strace

                                                    **3.多处理器编程**不原子、能乱序、不立即可见（来自于编译优化、处理器也是编译器）
多处理器程序=状态机（共享内存；非确定选择线程执行）
操作系统是最早的并发程序之一
多处理器系统
**并发**快速轮流
和**并行**：真正物理上同时进行

**线程API**                
create（fn）  
创建一个入口函数是fn的线程，并立即开始执行
语义：在状态中新增stack frame列表并初始化为fn(tid)
join()
等待所有运行的线程的fn返回
在main返回时会自动等待所有线程结束
语义：在有其他线程未执行完时死循环，否则返回
**编译时要增加 -lpthread**

证明线程确实共享内存
证明线程具有独立堆栈（以及确定它们的范围）
私房菜学Linux
man 7 pthreads
POSIX为我们提供了线程库
改写thread.h，使得线程拥有更大的栈
多处理器系统中的线程的代码可能**同时**执行
  两个线程同时执行x++

  
**lock**
**unlock**
  实现临界区之间的绝对串行化
  程序的其他部分依然可以并行执行
  99%的并发问题都可以用一个队列解决
    把大任务切分为可并行的小任务
    worker thread去锁保护的队列里取任务
    除去不可并行的部分，剩下的部分可以获得线性的加速
    
threads线程 
  创建：create
        pthread_create   
  thread.h=create+join

signal
  kill -KILL 进程号
  kill -TERM 进程号
       -STOP
       -CONT
optimization
volatile请不要优化它

./a.out | head -n 100000 | sort | uniq -c

    
系统调用不可优化的石头
内存可优化

单个处理器把汇编代码用电路编译成更小的μops
  每个μop都有Fetch,Issue,Exexute,Commit四个阶段
在任何时刻，处理器都维护一个μop的池子
  每一周期想池子补充尽可能多的μop
    "多发射"
  每一周期（在不违反编译正确性的前提下）执行尽可能多的μop
    "乱序执行、按序提交"
**多处理器间即时可见性的丧失**  
**宽松内存模型**的目的是使单处理器的执行更高效

1.atomic关键字可以帮我们生成原子化的读-改-写操作，从而避免多线程竞争问题
2.atomic有着极高的运行效率
3.atomic的特性是不稳定的
4.不是所有的编译器都支持Atomic


1.系统调用和函数调用一样，都可以通过寄存器传递参数，但会用syscall指令触发CPU异常，从而让操作系统接管后面的功能实现
2.操作系统调用会引发：CPU状态转换，CPU在用户态准备参数，然后切换到内核态完成功能
3.系统调用能够有效的隔离：应用程序和操作系统核心，提高整个系统的安全性
4.系统调用的实现，会因为CPU指令集的不同而不同，几乎所有重要的库函数都需要通过：系统调用来实现
过程：1.执行系统调用参数（用户态）2.执行陷入指令（用户态）3.执行相应的服务程序（内核态）4.返回用户态

            {用户态                   {特权指令                            {命令接口
CPU运行模式                   指令                        操作系统接口      {程序接口    命令接口和图形接口都需要用到系统调用
            {核心态                   {非特权指令                          {图形接口
自陷指令运行于用户态，是非特权指令
syscall是自陷指令

解决CPU大小端问题：用字符串的形式传递数值

**函数括号，堆栈，栈帧**
1.操作系统会为每个任务分配一段内存，当做任务堆栈，CPU则提供2个寄存器esp和ebp,用来标识：当前函数对堆栈的使用情况，随着函数的逐层调用，函数的栈帧会逐次堆叠，互不重合，随着函数的逐层返回，函数的栈帧会被就地放弃，但不会清理内存
2.正括号{用来保护上层主调函数（main）的栈帧，并设置被调函数（func）的栈帧，反括号}用来放弃被调函数的栈帧，同时，恢复主调函数（main）的栈帧。这样，被调函数执行完后，主调函数就能继续执行
3.ebp寄存器作为当前函数的栈帧基地址，配合一定的偏移，就可以读写函数体里的临时变量，如果一个变量是通过ebp寄存器间接访问的，那么它往往是临时变量，也叫栈变量
4.不同编译器对栈帧的实现方法略有不同，但思路相同

**堆栈隐患**
1.主调函数在调用函数时会把返回地址偷偷存放在堆栈中
2.被调函数返回时，会从堆栈中取出返回地址，引导CPU跳回到主调函数
3.不同编译器，在实现函数的返回上，会略有不同
缺点：返回地址这种关键数据离临时变量太近，容易被越界访问，导致程序意外崩溃



4.理解并发程序执行

