**编程模型**：对程序设计和执行过程的一套抽象规范、概念框架或方法论，它定义了开发者如何组织代码、处理数据、描述计算逻辑以及与系统（如硬件、操作系统、框架）交互的方式。
**段错误**:
  核心原理：虚拟内存和页表
  1.虚拟地址空间
  每个进程拥有独立的虚拟地址空间。程序访问的地址都是虚拟地址。
  2.页表映射机制
  CPU通过页表将虚拟地址转换为物理地址。页表项中记录：
  物理页帧号：数据实际存放位置
  权限标志位:R/W/X
  有效位：是否已映射物理内存
  3.触发段错误的**本质**
  当CPU访问一个虚拟地址时：
    页表项有效位=0->地址未映射物理内存->段错误
    权限不足->段错误



     段错误（Segmentation Fault）是操作系统对非法内存访问的强制保护机制。当程序试图访问**未被操作系统允许的内存区域**时，CPU 会触发硬件异常，操作系统收到异常后向进程发送 `SIGSEGV` 信号（默认行为是终止进程并生成 core dump）。以下是深入解析：

---

### 🧠 **核心原理：虚拟内存与页表**
1. **虚拟地址空间**  
   每个进程拥有独立的虚拟地址空间（32位系统4GB，64位系统巨大无比）。程序访问的地址都是虚拟地址。
   ```plaintext
   +------------------+ <-- 0xFFFFFFFF (内核空间)
   |      OS内核      |
   +------------------+ <-- 用户空间边界
   |      栈区        |  ↓ 由高地址向低地址增长
   |       ...        |
   |      堆区        |  ↑ 由低地址向高地址增长
   |  未初始化数据段  |
   |   已初始化数据段  |
   |     代码段        |
   +------------------+ <-- 0x00000000
   ```

2. **页表映射机制**  
   CPU通过**页表**将虚拟地址转换为物理地址。页表项中记录：
   - **物理页帧号**：数据实际存放位置
   - **权限标志位**：`R/W/X`（读/写/执行）
   - **有效位**：是否已映射物理内存

3. **触发段错误的本质**  
   当 CPU 访问一个虚拟地址时：
   - ❌ **页表项有效位=0** → 地址未映射物理内存 → **段错误**
   - ❌ **权限不足**（如向只读页写入数据）→ **段错误**

---

### 💥 **经典段错误场景详解**
#### 1️⃣ **空指针解引用（访问0x0地址）**
```c
int *p = NULL; 
*p = 42;  // 尝试写0x0地址 → 页表未映射此区域
```

#### 2️⃣ **访问已释放内存（Use-After-Free）**
```c
int *p = malloc(sizeof(int));
free(p);
*p = 10;  // 内存已被归还OS，页表项失效
```

#### 3️⃣ **栈溢出（Stack Overflow）**
```c
void infinite_recursion() {
    infinite_recursion(); // 栈空间耗尽 → 访问未映射的栈地址
}
```
> 系统通过 `RLIMIT_STACK` 限制栈大小（`ulimit -s` 查看）

#### 4️⃣ **只读内存写入**
```c
char *str = "常量字符串"; // 位于.rodata段（只读）
str[0] = 'A';            // 尝试修改只读内存 → 触发段错误
```

#### 5️⃣ **内存对齐问题（架构相关）**
```c
// ARM架构要求4字节对齐访问
int *p = (int*)((char*)malloc(100) + 1); 
*p = 10; // 未对齐地址访问 → CPU异常
```

---

### 🔧 **调试与预防实战指南**
#### 🛠️ 调试技巧
| 工具          | 命令示例                          | 作用                     |
|---------------|-----------------------------------|--------------------------|
| **GDB**       | `gdb ./a.out core`                | 分析core文件定位崩溃点   |
| **Valgrind**  | `valgrind --tool=memcheck ./a.out`| 检测内存错误             |
| **AddressSanitizer** | `gcc -fsanitize=address -g prog.c` | 实时内存检测             |

#### ✅ 预防措施
1. **指针安全**  
   - 初始化指针为 `NULL`
   - 访问前检查指针有效性
   ```c
   if (ptr != NULL) {
       *ptr = value;
   }
   ```

2. **内存管理**  
   - `malloc` 后检查返回值
   - 使用 `free` 后立即置空指针
   ```c
   int *p = malloc(size);
   if (!p) { /* 处理OOM */ }
   free(p); 
   p = NULL; // 防止悬空指针
   ```

3. **栈安全**  
   - 避免超大栈变量（>1MB用堆分配）
   - 递归设置深度限制

4. **代码规范**  
   - 使用 `const` 修饰只读数据
   - 危险操作（如 `memcpy`）添加长度检查
   ```c
   void safe_copy(char *dst, const char *src, size_t len) {
       if (dst && src && len > 0) {
           memcpy(dst, src, len);
       }
   }
   ```

---

### 🌟 **理解要点总结**
| 关键概念         | 说明                                                                 |
|------------------|----------------------------------------------------------------------|
| **虚拟地址空间** | 进程的"内存视图"，由OS管理映射                                      |
| **页表**         | 虚拟地址→物理地址的转换表，含权限控制                               |
| **SIGSEGV**      | 信号编号11，表示非法内存访问                                        |
| **Core Dump**    | 进程崩溃时的内存快照，用于事后分析                                  |
| **异步触发**     | 段错误可能在错误代码执行后延迟发生（如写入只读页不会立即崩溃）      |

> 📌 **重要认知**：段错误是操作系统的**保护机制**而非Bug！它阻止了可能引发系统级安全风险的行为（如篡改其他进程数据）。
> 

>**组合逻辑**：无记忆，输出仅依赖当前输入。没有存储功能的电路，其输出仅由当前时刻的输入信号决定。主要按照真值表，逻辑表达式来化简分析
>**时序逻辑**：存储元件一般由**触发器**实现。是在有限个状态间按照一定的规律转化的，所以有时又把时序电路称为**有限状态机**。因为其带有**存储**的功能。**时间**
>两者的区别在于是否具有记忆功能，以及输入和输出的依赖关系不同
>**阻塞赋值**：=立即执行，顺序阻塞。赋值语句执行时会阻塞后续语句的执行，即当前语句完成赋值后，下一条语句才能开始执行。变量的值会立即更新。
>仅用于组合逻辑电路（如逻辑门）
和
>**非阻塞赋值**<=延迟更新，并行执行。赋值语句不会阻塞后续语句的执行，所有非阻塞语句不会阻塞后续语句的执行，所有非阻塞语句在快内“同时评估、延迟更新”。
>在仿真过程中，非阻塞赋值的执行分为两步:1.评估阶段。2.更新阶段
>仅用于时序逻辑电路（如触发器、寄存器、计数器等）

同一个信号在多个always块中被赋值，阻塞赋值和非阻塞赋值都会有什么反应
**1.仿真**：验证设计的功能正确性，本质是通过软件工具模拟电路的行为，验证设计是否符合预期功能
核心目的是验证电路的逻辑功能是否符合设计需求（比如加法器是否能否正确相加、状态机是否能按逾期表跳转）
排查设计中的逻辑错误（如时序冲突、功能漏洞、边界异常等）
基本过程：
1.编写测试激励
2.搭建仿真环境
3.运行仿真
4.分析结果
不依赖具体的硬件工艺，只关注逻辑功能
**2.综合**：将设计转化为硬件电路结构
综合是将高层次的抽象设计转换成低层次的 硬件电路结构



**掩码**概念： 

**位运算和bitset**:

gcc 
**-O0**:默认级别无优化
**-O1**：基础优化
gcc -fsanitize=undefined int_overflow.c

优化
例：常数传播
clang -S -foptimization-record-file=- a.c
clang -S -foptimization-record-file=- a.c -O1

clang -S a.c -ftime-report
优化耗时久--代码怎么写的

二进制
汇编
gcc -c a.c
riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32 -c a.c
#alias rv32gcc="riscv64-linux-gnu-gcc -march=rv32g -mabi=ilp32"
二进制文件不能用文本编辑器打开来阅读，需要binutils(Binary Utilities)或llvm的工具链
objdump -d a.o
riscv64-linux-gnu-objdump -d a.o
#alias rvobjdump="riscv64-linux-gnu-objdump"
llvm-objdump -d a.o #llvm的工具链可以自动识别目标文件的架构，用起来更方便

执行：把可执行文件加载到内存，跳转到程序，执行编译出的指令序列
加载：运行时的环境（宿主操作系统/QEMU）

                                                    **实现定义行为和  ABI**

C语言标准并没有明确定义类型的长度，而是全部交给具体实现来定义，不过定义了类型的最小范围
select

未指定行为，重新编译后可能得到不同的结果。
  表达式i=i++的求值顺序未指定，函数参数的求值顺序未指定
实现定义行为：在相同环境下运行可以得到相同的结果，移植到另一个环境

（绝对禁止）未定义行为；多次运行可能也无法得到正确的结果
  访问数组越界，使用未初始化的变量，对空指针解引用，整数溢出

ABI：应用程序二进制接口
是计算机系统软硬件协同的重要体现
  程序的运行结果与源代码，编译器，运行时环境，OS，硬件等都有关系

预处理->编译->汇编->链接->执行
编译=词法分析->语法分析->语义分析->中间代码生成->优化->目标代码生成
学会使用工具和日志理解其中的细节

通过ABI手册了解Implementation-defined Behavior
认识C语言标准，编译器，操作系统，运行库，处理器之间的协助
程序的运行结果与源代码和上述因素都有关系

                                                       **程序的执行和模拟器**
指令序列的状态机的实现方式
C程序的状态机的实现方式
                                                      **1.freestanding运行时环境**

                                                          **2.YEMU指令如何执行**

                                                      
                                                        **3.编写可读可维护的代码：**
函数名明确，封装性好，模块化，版本控制，单元测试
防御性编程：
不相信外界的输入/其他函数传递的参数，通过断言提前拦截非预期情况。让断言失败时输出更多信息  。
减少代码中的隐含依赖
：#define MSIZE 1024
把定义放在头文件
共性的问题，粘贴的地方都需要改
编写可复用的代码
通过变量，函数，宏等方式消除重复/相似的代码
引入中间变量，不言自明
对齐的代码更容易发现错误，不言自证

CEMU目前只支持很少部分的C语言语法，YEMU也只支持两条指令
若二者功能完整，则下面两种方式执行C程序的效果等价
  在CEMU上执行C程序
  将C程序编译成指令序列，并在YEMU上执行

模拟器/解释器=状态机的实现
YEMU=指令集模拟器=用C语言实现指令集手册定义的状态机
  自定义freestanding运行时环境
  支持两条指令的指令周期：取指、译码、执行、更新PC
CEMU=C语言解释器=用其他语言实现标准C标准手册的状态机
  hosted运行时的环境
  支持若干简单

                                                **从晶体管到CPU**
                                                1.通过晶体管实现0和1
  数字芯片
  栅极
CMOS=用MOS管的开关特性实现0和1
CMOS=Complementary MOS=nMOS+pMOS
                                                2.通过晶体管搭建门电路
三输入与非门
：在门电路搭建
：在晶体管层面搭建
体现了ASIC设计中全定制电路的优势
：延迟低，功耗低，面积小

                                                3.通过门电路搭建基本组合逻辑电路
译码器
  检测n位输入的值，使2^n位输出中的相应位为1
  若输入为X，则输出的第X位为1，其他位为0
  该输出也称为独热码
  常用于寻址：输入某地址，生成相应内容的有效信号
编码器
  与译码器功能相反
优先编码器
  可支持独热码以外的输入，单只编码优先级最高的位
多路选择器
  根据选择器选择一路输入
  将选择端看作地址，则类似一次寻址操作
比较器
半加器
全加器


                                                4.时序逻辑电路
                                                5.存储器
                                                6.YPC-用数字电路搭建简单处理器

                                                **NEMU代码导读**
可以输出make工具的调试日志
  :make -d  
  make --debug=v
  也可以通过strace工具了解make工具的行为
  stat系统调用可以查询文件信息
了解程序/工具行为的两种方法
  看源码：静态细节，较繁琐
  看踪迹：动态行为，不全面

make -nB //-B可以强制make构建所有目标，即使他们已经是最新的
vim 普通模式下输:%s/旧字符/新字符/g（一键替换）

#只保留gcc或g++开头的行
：%！grep "^\(gcc\|g++\)"

采用容易理解的方式编码，可能会使得代码难以维护
要采用容易维护的编码方式，就需要采用更多的高级功能对重复代码进行抽象

初学者，容易感知编码的复杂度，对代码的可维护性感知较弱
需要在调试的过程中吸取教训
编码的开销是一次性的，但将来还要不断维护这个代码
对于一定规模的项目来说，可维护的代码比容易理解的代码更重要。

查看宏展开结果/代码对齐


                                                
锁存器




头文件
获取位置:阅读工具的日志（查找是否支持verbose,log等选项）
gcc -E a.c --verbose > /dev/null
