**指令集评价标准**：
1.成本
2.简洁性
3、性能=程序执行时间
4.架构和具体实现的分离
**分支延迟槽**：跳转指令->跳转指令的下一条静态指令（延迟槽指令）->跳转/不跳转
  需要软硬件协同才能工作,处理器先不等待分支指令的执行结果，先无条件执行延迟槽中的指令，使得无论是否跳转都能正确的执行程序
**一旦写入ISA手册，就不能删掉**
 5.提升空间
 可以添加指令
 6.代码大小
 嵌入式处理器：更小的代码=更小的存储器=更低的成本
 高性能处理器：更小的代码=更高的缓存命中率=更低的功耗&更高的性能
   访问功耗：片外DRAM>片内SRAM
 X86是变长指令集
7.易于编程/编译/链接
更多的通用**寄存器**有利于**编译器**将变量分配到寄存器，提升程序性能
提供相对PC的分支和数据寻址，可生成更高质量的**位置无关代码**
   
**RISC-V指令集起源**
**通用的ISA**
兼容现有软件栈和编程语言
本地硬件指令集，不是虚拟机
所有规模的处理器都适用
可以设计出所有的微架构，包括顺序和乱序，单发射和超标量等
支持高度定制化，成为定制加速器的基础
稳定。基础部分不会改变，不会突然消失
**RISC-V特色**
**简单**
**干净的设计**
没有历史包袱
与微结构设计解耦
**模块化**：很小的标准基础ISA，很多标准扩展
**为扩展性和定制化而设计**
变长的指令编码
为扩展ISA预留了很多操作码空间
**稳定**
通过可选扩展而不是新版本来进行增强
属于开放的RISC-V基金会所有，不受一家公司的决定和沉浮所影响
**通过模块化应对不同的应用场景**
**四种基础整数指令集**：RV32I,RV64I,RV128I,RV32E
RV32E是“16个寄存器”的RV32I变种
基础指令只有约50条
**标准扩展：**
M-整数乘除
A-原子操作
F-单精度浮点
D-双精度浮点
G-IMAFD，一个通用的组合
C-压缩指令
除了RVC，上述指令均采用固定4字节的指令长度
**根据需求自由组合**
嵌入式（处理器越小越好）-RV32E
嵌入式（存储器越小越好）-RV32IC
教学-RV64IMA
桌面-RV64GC
高性能-RV64GCBV
还支持自定义指令-属于非标准扩展
**变长指令集**
**定长指令集**
**基础指令集和大部分标准扩展采用4字节定长指令（RVC是2字节）**
对绝大部分RISC-V处理器来说，指令是定长的
**通过模块化，更长的指令只会用在特定应用场景**
只有采用变长指令扩展的RISC-V处理器，才需要支持变长指令
不影响已经设计的RISC-V处理器
**本质**：模块化特性根据需求对不同处理器的实现细节进行隔离
指令设计
编程模型
32个通用寄存器（GPR）+PC
从R[0]中读出结果恒为0
 指令格式
**6种指令格式，长度均为32位，简化了译码器的实现**
**三地址指令，即指令操作数有3个**
在所有的指令格式中，rd,rs1,rs2总是在相同的位置
实现时可节省不必要的选择器
**0x00000000和0xffffffff是非法指令**
前者常在初始化的数据区域出现
后者常在存储型设备访问错误时出现，如未编程，通信失败等
防御性编程的理念：尽早捕捉错误
**立即数均进行符号扩展**
可以直接表示负数：0xfff解释成-1，对软件来说比4095常用的多
可以用addi来实现subi
**立即数编码方式**
需要从**硬件实现角度**来理解
对于生成的立即数，其中每个比特来源于不同类型指令的不同位置
因此需要通过**选择器**来生成立即数的每个比特**
**通过尽量减少每个比特的来源位置情况，来减少选择器的输入端，从而节省成本**
**代价**：编译器生成指令时需要更长时间，但这是一次性开销
**U型指令**
立即数划分成20 + 12的考量
：在软件中，大部分常数的绝对值要么很小，要么很大
**访存指令**
没有专门的push，pop指令，可以通过以sp作为基址寄存器来实现
不对齐访存的处理
RISC-V的方案：让执行环境来决定是否支持不对齐访存
**无条件跳转指令**
jr,jalr,j,jal








